# Security Overview

The OpenSigner system is composed of multiple components that communicate over HTTP.
Communication includes sensitive data such as key shares or access tokens, therefore **it is crucial
to ensure communication is secured through TLS** and HTTPS is enforced.

## Trust Model

It is important to be aware of the root of trust at each point in the system.
The key is split into three shares, two of them are enough to reconstruct the key.
Once a user logs into a device, each one of the three shares is stored in:

- **User's device**: the domain-protected storage of the browser.
- **Hot storage**: users can access this share through an access token granted by the authentication service.
- **Cold storage**: users can access this share provided a request is made with valid entropy and a valid token is issued by the authentication service.

The system relies on the following roots of trust:

### Authentication Service

The authentication service is responsible for validating the user's identity and granting access tokens.
It must be trusted to securely handle user credentials and issue tokens that can be used to access shares.
While the authentication service API is provided, each implementation will be tied to each project's specific needs,
and needs to be done with care.

The impact of a compromised authentication varies depending on the context:

- If the attacker also has access to the user's device and the key was previously reconstructed there:
    - They can fully recover the secret because user authentication directly unlocks the hot share.
- If the attacker only has the user's credentials but no device access, the outcome depends on how cold share recovery is handled:
    - With *user-based recovery*, an extra password or passkey (independent from the user's main credentials) is needed to decrypt the cold share.
    - With *automatic recovery*:
        - Without 2FA: the attacker can easily recover the user's secret key just by using the stolen credentials.
        - With 2FA: user interaction is required to recover the secret, as the attacker would need to compromise the 2FA method as well.

:::tip[Best Practice]
The safest way to protect a cold share is to use user-based recovery with a completely separate password/passkey that's unrelated to the primary authentication method.
:::

### Application Logic

2 out of 3 shares are enough to reconstruct the key. For this reason, the system
comes with audited, open source implementations of the storage and management systems of two of the three shares.

- **iFrame**:
The iFrame is not only the storer (in domain-based browser storage), but also the actor responsible for
splitting and reconstructing the keys. It is the only component that will have access to the full, reconstructed key.

- **Cold Storage**: The cold storage is the stepping stone for every login in a new device.
The share it contains is encrypted with either user or project entropy.

### Environment

Use trusted browsers, servers, execution environments...

### Project Owner

Users with authentication key recovery trust on the owner of the project they belong to with part of the
entropy of their recovery share.

### Transport

Sensitive data, such as access tokens and key shares, travel over the network when transmitted from one component to
another. It is vital to have and enforce secure communication channels, such as HTTPS, to prevent eavesdropping and tampering.
Make sure to validate TLS certificates to prevent Man In The Middle (MITM) attacks.
[HSTS](https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) should be used for browser-oriented operations.

## Next Steps

- Learn about [Recovery Methods](/security/recovery-methods) - password, passkey, and automatic recovery options
- Explore [Deployment Scenarios](/security/deployment-scenarios) - hosting configurations and their security implications
- Read the [Threat Analysis](/security/threat-analysis) - potential attack vectors and mitigations
