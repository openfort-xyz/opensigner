---
title: Recovery Methods
description: The three supported recovery methods are _automatic_, _password_ and _passkey_ based recovery. Each has different security considerations.
---

# Recovery Methods

The three supported recovery methods are _automatic_, _password_ and _passkey_ based recovery. Each has different security considerations.
Each refers to how the recovery share is encrypted, and how the user can access it.

## Password-Based Recovery

In password-based recovery, the recovery share is encrypted with a user-provided password.
Recovery share encryption and decryption happen in the iFrame, making the user the sole owner of the entropy guarding the share.
Check out the [**password-based signup**](/actions/signup#user-with-password-recovery) section for more details.

:::info[Encryption Details]
When setting a recovery password, the iframe uses the open-source [@openfort-xyz/crypto-js](https://github.com/openfort-xyz/crypto-js)
library to first derive a secure key.

The key derivation algorithm is `Argon2` with `12` iterations using `64MiB` of memory and a `128` bit long salt.

A `256` bit length encryption key is then derived and used to encrypt the cold share.

The cold share is encrypted using `AES-CBC` with the previously derived key. The Initialization Vector (IV) is
generated by the iframe and is `128` bits of length, too.
:::

## Passkey Recovery

Passkey recovery works similarly to password-based recovery: an encryption key is derived from user input
and shares are encrypted and split following the same pattern.
In passkey-based recovery the cold share plaintext never leaves the client, neither does the derived encryption key.
OpenSigner stores the following information:
- The internal passkey ID, issued by the passkey authenticator
- The encrypted (cold) share
- Some environment-related information (browser name, OS, OS Version and Device information)

:::info[Encryption Details]
The cold share is encrypted using AES256 in CBC mode. The encryption key is derived using the Pseudo Random Function (PRF)
extension, available for most modern passkeys. This extension allows an authenticated user to derive encryption keys.

As in password based recovery, the IV is 128 bits of length and is generated by the iframe itself.
:::

## Automatic Recovery

In automatic recovery, key encryption and decryption happen in the cold storage.
While providing the benefit of not requiring the user to remember a password, it introduces some risks:

### Ownership Risk

If the entity in control of the cold storage (which contains one of the two shares required to reconstruct the encryption key)
is also the one in control of the other encryption key shares, it can access the full recovery share. This, when combined with control
over one of the other two shares, allows the entity to reconstruct the key.

### Network Risk

The raw encryption key travels over the network from the iFrame to the cold storage and can be intercepted.
Mitigate this with proper network security measures.
Check out the [**automatic recovery signup**](/actions/signup#user-with-automatic-recovery) section for more details.

### The 3 Key Shares vs The 2 Encryption Parts

#### System 1: Key Shares (Shamir's Secret Sharing)
The **user's private key** is divided into 3 shares:
1. **Device Share**: Stored in the browser's localStorage/IndexedDB.
2. **Hot Share**: Stored in the Host's Hot Storage (such as Openfort).
3. **Cold Share**: Stored in the Host's Shield (Cold Storage).

:::tip
You need **2 of 3** shares to reconstruct the private key.
:::

#### System 2: Encryption Parts (Project Encryption Key)
The **Cold Share is ENCRYPTED**. To decrypt it, you need the Project Encryption Key, which is also divided:
1. **Developer Encryption Part**: Held by the Developer (You). Created once and must be stored securely.
2. **Shield Encryption Part**: Stored in the Shield database (managed by the Host).

:::tip
You need **BOTH** parts to decrypt the Cold Share.
:::

### Non-Custodial in cloud hosting (such as Openfort)

For a Cloud Host (like Openfort) to reconstruct a user's private key, it would need 2 shares.
-   It has the **Hot Share** (1/3).
-   It has the **Cold Share** (2/3), **BUT** it is encrypted.
-   To decrypt the Cold Share, it needs the **Developer Encryption Part**, which **only the Developer holds**.

Therefore, the Cloud Host cannot decrypt the Cold Share and remains with only 1 usable share (Hot Share), which is insufficient to reconstruct the private key.

### Secure Usage: Encryption Sessions

To avoid sending the **Developer Encryption Part** with every request (which would verify the "custody" rule but increase exposure risk), use **Encryption Sessions**.

1.  Backend calls `POST /project/encryption-session` with the `encryption_part`.
2.  Shield returns a temporary, one-time use `session_id`.
3.  The iFrame uses this `session_id` to decrypt the Cold Share.
4.  The session expires immediately after use.

This ensures the critical secret (Developer Part) is not constantly exposed on the network.

:::info[Encryption Details]
The cold storage implementation generates an encryption key for the recovery share,
splits it into three (one is kept by the cold storage, one given to the caller, the last one deleted),
then uses AES-GCM (Advanced Encryption Standard in Galois/Counter Mode) to store one of the shares in a database.

The nonce, or IV, is 96 bits of length in this case, as recommended for this particular mode of AES.

As in Password Recovery Mode, 256-bit length keys are used. This key is generated and split in shield.
The key is generated using a secure RNG (golang's `crypto/rand`).
:::


## OTP Verification for Automatic Recovery

:::warning[Critical Security Consideration]
In automatic recovery without OTP, the backend has access to both hot storage and cold storage. Using a valid user JWT, the system can coordinate access to these shares and reconstruct a user's private key on the backend. **No additional user-held secret is required beyond standard user authentication.**
:::

### Why OTP is Essential

To enhance the security of automatic recovery, you can enable OTP verification for your Shield project.
When enabled, Shield requires an OTP to create an encrypted session for share decryption.
The OTP is sent to the user's contact information (either email or phone number).
This reduces the control that the cold storage host has over the stored shares.

### How OTP Prevents Backend Reconstruction

| Scenario | Backend Can Reconstruct Key? | User Action Required? |
|----------|------------------------------|----------------------|
| Automatic recovery **without OTP** | ✅ Yes | ❌ No |
| Automatic recovery **with OTP** | ❌ No | ✅ Yes - must provide OTP |
| Password-based recovery | ❌ No | ✅ Yes - must provide password |
| Passkey-based recovery | ❌ No | ✅ Yes - must authenticate passkey |

### Enabling OTP

When OTP is enabled:
1. User initiates a recovery/signing operation
2. Shield sends an OTP to the user's registered email or phone
3. User provides the OTP to the iframe
4. Only after OTP verification can the cold share be decrypted

This ensures that even with valid authentication tokens, the backend cannot unilaterally access user keys without active user participation.
