# Recovery Methods

The three supported recovery methods are _automatic_, _password_ and _passkey_ based recovery. Each has different security considerations.
Each refers to how the recovery share is encrypted, and how the user can access it.

## Password-Based Recovery

In password-based recovery, the recovery share is encrypted with a user-provided password.
Recovery share encryption and decryption happen in the iFrame, making the user the sole owner of the entropy guarding the share.
Check out the [**password-based signup**](/actions/signup#user-with-password-recovery) section for more details.

:::info[Encryption Details]
When setting a recovery password, the iframe uses our open-source [@openfort-xyz/crypto-js](https://github.com/openfort-xyz/crypto-js)
library to first derive a secure key.

Our key derivation algorithm is `Argon2` with `12` iterations using `64MiB` of memory and a `128` bit long salt.

A `256` bit length encryption key will be then derived and used to encrypt the cold share.

The cold share will be then encrypted using `AES-CBC` with the previously derived key. The Initialization Vector (IV) will
be generated by the iframe and will be `128` bits of length, too.
:::

## Passkey Recovery

Passkey recovery behaves almost identically to password based recovery: an encryption key is derived from some user input
and shares are encrypted and split following pretty much the same pattern.
In passkey-based recovery the cold share plaintext never leaves the client, neither does the derived encryption key.
OpenSigner will instead store the following information:
- The internal passkey ID, issued by the passkey authenticator
- The encrypted (cold) share
- Some environment-related information (browser name, OS, OS Version and Device information)

:::info[Encryption Details]
The cold share is encrypted using AES256 in CBC mode. The encryption key is derived using the Pseudo Random Function (PRF)
extension, available for most modern passkeys. This extensions allows an authenticated user to derive encryption keys.

As in password based recovery, the IV will be of 128 bits of length and will be generated by the iframe itself.
:::

## Automatic Recovery

In automatic recovery, key encryption and decryption happen in the cold storage.
While providing the benefit of not requiring the user to remember a password, it also proposes some new risks:

### Ownership Risk

If the entity in control of the cold storage (which contains one of the two shares required to reconstruct the encryption key)
is also the one in control of the other encryption key shares, it can access the full recovery share. This, when combined with control
over one of the other two shares, allows the entity to reconstruct the key.

### Network Risk

The raw encryption key travels over the network from the iFrame to the cold storage, which could be intercepted.
This can be mitigated with proper network security measures.
Check out the [**automatic recovery signup**](/actions/signup#user-with-automatic-recovery) section for more details.

:::info[Encryption Details]
Our cold storage implementation generates an encryption key for the recovery share,
splits it into three (one will be kept by the cold storage, one given to the caller, the last one deleted),
then uses AES-GCM (Advanced Encryption Standard in Galois/Counter Mode) to store one of the shares in a database.

The nonce, or IV, will be 96 bits of length in this case, as it is recommended for this particular mode of AES.

As in Password Recovery Mode, 256-bit length keys will be used. This key will be generated and split in shield.
The key is generated using a secure RNG (golang's `crypto/rand`).
:::

---

## Two-Factor Authentication (2FA) for Automatic Recovery

:::warning[Critical Security Consideration]
In automatic recovery without 2FA, the backend has access to both hot storage and cold storage. Using a valid user JWT, the system can coordinate access to these shares and reconstruct a user's private key on the backend. **No additional user-held secret is required beyond standard user authentication.**
:::

### Why 2FA is Essential

To enhance the security of automatic recovery, you can enable OTP verification for your Shield project.
When enabled, Shield will require an OTP to create an encrypted session for share decryption.
The OTP will be sent to the user's contact information (either email or phone number).
This reduces the control that the cold storage host has over the stored shares.

### How 2FA Prevents Backend Reconstruction

| Scenario | Backend Can Reconstruct Key? | User Action Required? |
|----------|------------------------------|----------------------|
| Automatic recovery **without 2FA** | ✅ Yes | ❌ No |
| Automatic recovery **with 2FA (OTP)** | ❌ No | ✅ Yes - must provide OTP |
| Password-based recovery | ❌ No | ✅ Yes - must provide password |
| Passkey-based recovery | ❌ No | ✅ Yes - must authenticate passkey |

### Enabling 2FA

When 2FA is enabled:
1. User initiates a recovery/signing operation
2. Shield sends an OTP to the user's registered email or phone
3. User provides the OTP to the iframe
4. Only after OTP verification can the cold share be decrypted

This ensures that even with valid authentication tokens, the backend cannot unilaterally access user keys without active user participation.

---

## Recovery Method Comparison

| Feature | Password | Passkey | Automatic | Automatic + 2FA |
|---------|----------|---------|-----------|-----------------|
| User remembers secret | ✅ Password | ❌ Device-based | ❌ None | ❌ None |
| Cold share encrypted client-side | ✅ | ✅ | ❌ | ❌ |
| Requires user action for recovery | ✅ | ✅ | ❌ | ✅ (OTP) |
| Backend can reconstruct key alone | ❌ | ❌ | ✅ | ❌ |
| Best for | Maximum security | Convenience + security | Simplest UX | Balanced security/UX |
